#+OPTIONS: ^:{}
* Emacs for C++ developers
  :PROPERTIES:
  :ID:       o2b:d260ed4e-b55b-46b5-9fcd-6d5a6bca36c7
  :END:
#+OPTIONS: toc:nil

Author: Chen Bin <chenbin DOT sh AT gmail DOT com>
Created: <2013-07-06>
URL: [[http://blog.binchen.org]]

** warning
This is only a draft. I recorded my points here and will add more content later.
** Introduction
Doing all the C++ development in Emacs is now at least as good as Visual Studio. Though some minor set up is still needed.
** Project management
Use cmake.
** code completion
*** [[http://en.wikipedia.org/wiki/Intelligent_code_completion][Intelligent code completion]]
This feature is also called intellisense in Visual Studio.

Here is an example how intellisense should work,
#+BEGIN_SRC c++
struct ClassA{
    int valueA;
    void functionB(int a) {
        printf("a=%d",a);
    }
};

int main(void) {
    ClassA a;
    a. // when input ".", the candidate "valueA"" and "functionB"" should be displayed in a popup
    return 0;
}
#+END_SRC

Currently I'm using [[https://github.com/company-mode/company-mode][company-mode]]. It's actively maintained and has everything in one bundle.

There is also another addon [[https://github.com/auto-complete/auto-complete][auto-complete]]. It's as good as company-mode. But you need install auto-complete's own plugin auto-complete-clang.

Addons like company-mode and auto-complete only provide the front end UI. The code parsing thing is done in backend command line tool.

The most popular parsing tool is [[http://clang.llvm.org/][Clang]] or [[http://www.gnu.org/software/global/][GNU Global]]. [[http://ctags.sourceforge.net/][Ctags]] could also be used sometimes. But Ctags use only regular expression to analyze the code. So its result is not as precise as Clang or GNU Global.

In real project, you need tell Clang or GNU Global where to scan the source files. We usually only scan the directory containing C++ header files.

[[http://cedet.sourceforge.net/][Cedet]] is similar plugin and has been mentioned by many articles. But in my opinion it's out of scope now because it's hard to set up and slow.
*** Other code completion
In reality, I found I use hippie-expand more often simply because it's more responsive
** Software configuration management (SCM)
The best software is git.

- the old commands in emacs is still convienent
- Many people use magit. Maybe its most useful feature is you can interactively create new commits by marked hunks in git cache/index.
- I don't use magit. Command line looks good enough for me.
** code editing
- I use evil-mode, vim key binding, end of story
- complete line in evil-mode is actually very useful
- search and replace in evil-mode is even better than the orginal vim one
- I use evil-nerd-commenter to comment/uncomment code
** code navigation
- for navigation in current file, I use imenu
- for navigation between files, you can use cscope or gtags
- both are good enough for me. I use gtags simply because it's udpated more often
- ctags is good for C and simple C++ code. Avoid writing complex C++ code could be a better idea. Then you can use ctags.
** flymake (real time syntax check)
- I found it a huge boost to my productivity
- The headache to write makefile to make flymake work is huge. For example, Manually insert correct include C++ header directories into makefile.
- I suggest use cmake and cpputils-cmake to do this job automatically 
** compile
- compile mode in Emacs. All the handy hot keys to locate the next previous compile error.
- you can change variable compile-command from "make" to "make -C /whatever/directory/you/want" in elisp.
- hide the compiling message window in elisp when compiling succeeds.
** debug
- I use M-x gud-gdb which works on gdb 6.3. On OSX 10.7.3, gdb 6.3 is the installed by default.
- Set hot key for gud-run
- Or only use the cli gdb plus some tile window manager like i3. Because for real world debugging, the actual thing you need do is watch the variable, read the context of the code.
- Gud and dired could be programmically changed, so you can jump to the directory of executable easily
** documentation
- The only meaningful documentation these days for me is to search google, search stackoverflow. So I need trigger firefox from Emacs.
** clipboard
- It's useful when you copy/paste code from firefox
- I found the only reliable way is use cli tool for cross-platform development. xclip is not as reliable as xsel.
** file
- jump to the corresponding header. You know "M-x ff-find-other-file"? In real projects, you need give set up 3rd party C++ directories for search. cpputils-cmake can help you. But of course you can do it manually.
- ido is good
- helm plugins are fine. But "M-x helm-ls-git-ls" is very useful if you use git.
- sometime I just use "M-x rgrep"
- Os grep plus percol by mooz plus some handy clipboard bash function plus ":e" in evil-mode is very useful to search and open file quickly
- I don't understand why everything should be done in Emacs, Some handy shell tools plus Emacs is much more powerful.
** window 
- I usually open 4~8 sub-windows
- Use window-numbering.el, the hotkeys are "M-NUM".
- I use evil-mode, so no need to input numeric argument
- I am also using other window navigation plugins, but they are rarely used.
- winner-mode, undo the windows layout
** command
- I use smex to input commands because I cannot remember hot keys because hot keys are different in different modes.
** code template
- yasnippet
- My tip is to assign a unique hot key for yas/expand. So you can use single character as the key of your most frequently used snippet. "a" for assert "l" for log and "i" for include. Other snippets are rarely used actually.
